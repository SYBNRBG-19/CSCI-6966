-- test/VulnerabilityScannerSpec.hs
module VulnerabilityScannerSpec (spec) where

import Test.Hspec
import CFGGenerator
import Types
import VulnerabilityScanner
import BinaryParser (Instruction(..))

import qualified Data.Map as Map

spec :: Spec
spec = describe "VulnerabilityScanner" $ do
  it "detects multiple vulnerabilities in the CFG" $ do
    let instrs = [instrCall "printf", instrCall "strcpy", instrPush, instrPush, instrPop]
    let cfg = createTestCFG instrs
    let vulns = scanForVulnerabilities cfg
    length vulns `shouldBe` 3
    map vulnType vulns `shouldMatchList` ["Format String Vulnerability", "Buffer Overflow Vulnerability", "Stack Integrity Vulnerability"]

  it "does not report vulnerabilities when there are none" $ do
    let instrs = [instrCall "safeFunction", instrPush, instrPop, instrRtn]
    let cfg = createTestCFG instrs
    let vulns = scanForVulnerabilities cfg
    vulns `shouldBe` []

-- Helper functions
createTestCFG :: [Instruction] -> CFG
createTestCFG instrs = CFG
  { cfgBlocks = Map.fromList [("0x1000", BasicBlock "0x1000" instrs)]
  , cfgEdges = Map.empty
  }

instrCall :: String -> Instruction
instrCall funcName = Instruction
  { address = "0x1002"
  , bytes = ""
  , mnemonic = "call"
  , operands = funcName
  }

instrPush :: Instruction
instrPush = Instruction
  { address = "0x1000"
  , bytes = ""
  , mnemonic = "push"
  , operands = "eax"
  }

instrPop :: Instruction
instrPop = Instruction
  { address = "0x1001"
  , bytes = ""
  , mnemonic = "pop"
  , operands = "eax"
  }

instrRtn :: Instruction
instrRtn = Instruction
  { address = "0x1002"
  , bytes = ""
  , mnemonic = "ret"
  , operands = ""
  }
